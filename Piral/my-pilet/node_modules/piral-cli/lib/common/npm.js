"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeExternals = exports.makePiletExternals = exports.getPackageVersion = exports.getGitPackageVersion = exports.getFilePackageVersion = exports.getPackageName = exports.combinePackageRef = exports.isLinkedPackage = exports.getCurrentPackageDetails = exports.dissectPackageName = exports.makeFilePath = exports.makeGitUrl = exports.isGitPackage = exports.isLocalPackage = exports.findLatestVersion = exports.findSpecificVersion = exports.findTarball = exports.createPackage = exports.publishPackage = exports.installPackage = exports.installDependencies = exports.bootstrapMonorepo = exports.detectMonorepo = exports.detectMonorepoRoot = exports.isMonorepoPackageRef = exports.determineNpmClient = exports.getLernaNpmClient = exports.getLernaConfigPath = exports.detectYarn = exports.detectNpm = exports.detectPnpm = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const log_1 = require("./log");
const config_1 = require("./config");
const constants_1 = require("./constants");
const inspect_1 = require("./inspect");
const io_1 = require("./io");
const helpers_1 = require("../helpers");
const _1 = require(".");
const gitPrefix = 'git+';
const filePrefix = 'file:';
function isProjectReference(name) {
    const target = (0, path_1.resolve)(name, 'package.json');
    return (0, io_1.checkExists)(target);
}
function detectPnpm(root) {
    return new Promise((res) => {
        (0, fs_1.access)((0, path_1.resolve)(root, 'pnpm-lock.yaml'), fs_1.constants.F_OK, (noPnpmLock) => {
            res(!noPnpmLock);
        });
    });
}
exports.detectPnpm = detectPnpm;
function detectNpm(root) {
    return new Promise((res) => {
        (0, fs_1.access)((0, path_1.resolve)(root, 'package-lock.json'), fs_1.constants.F_OK, (noPackageLock) => {
            res(!noPackageLock);
        });
    });
}
exports.detectNpm = detectNpm;
function detectYarn(root) {
    return __awaiter(this, void 0, void 0, function* () {
        return !!(yield (0, io_1.findFile)(root, 'yarn.lock'));
    });
}
exports.detectYarn = detectYarn;
function getLernaConfigPath(root) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', 'Trying to get the configuration file for Lerna ...');
        const file = yield (0, io_1.findFile)(root, 'lerna.json');
        if (file) {
            (0, log_1.log)('generalDebug_0003', `Found Lerna config in "${file}".`);
            return file;
        }
        return undefined;
    });
}
exports.getLernaConfigPath = getLernaConfigPath;
function getLernaNpmClient(root) {
    return __awaiter(this, void 0, void 0, function* () {
        const file = yield getLernaConfigPath(root);
        if (file) {
            try {
                return require(file).npmClient;
            }
            catch (err) {
                (0, log_1.log)('generalError_0002', `Could not read lerna.json: ${err}.`);
            }
        }
        return undefined;
    });
}
exports.getLernaNpmClient = getLernaNpmClient;
/**
 * For details about how this works consult issue
 * https://github.com/smapiot/piral/issues/203
 * @param root The project's root directory.
 */
function determineNpmClient(root, selected) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!selected || !helpers_1.clientTypeKeys.includes(selected)) {
            (0, log_1.log)('generalDebug_0003', 'No npm client selected. Checking for lock files ...');
            const [hasNpm, hasYarn, hasPnpm] = yield Promise.all([detectNpm(root), detectYarn(root), detectPnpm(root)]);
            const found = +hasNpm + +hasYarn + +hasPnpm;
            (0, log_1.log)('generalDebug_0003', `Results of the lock file check: npm = ${hasNpm}, Yarn = ${hasYarn}, Pnpm = ${hasPnpm}`);
            const defaultClient = config_1.config.npmClient;
            if (found !== 1) {
                const lernaClient = yield getLernaNpmClient(root);
                if (helpers_1.clientTypeKeys.includes(lernaClient)) {
                    (0, log_1.log)('generalDebug_0003', `Found valid npm client via Lerna: ${lernaClient}.`);
                    return lernaClient;
                }
            }
            else if (hasNpm) {
                (0, log_1.log)('generalDebug_0003', `Found valid npm client via lockfile.`);
                return 'npm';
            }
            else if (hasYarn) {
                (0, log_1.log)('generalDebug_0003', `Found valid Yarn client via lockfile.`);
                return 'yarn';
            }
            else if (hasPnpm) {
                (0, log_1.log)('generalDebug_0003', `Found valid pnpm client via lockfile.`);
                return 'pnpm';
            }
            if (helpers_1.clientTypeKeys.includes(defaultClient)) {
                (0, log_1.log)('generalDebug_0003', `Found valid Pnpm client the default client: "${defaultClient}".`);
                return defaultClient;
            }
            (0, log_1.log)('generalDebug_0003', 'Using the default npm client.');
            return 'npm';
        }
        return selected;
    });
}
exports.determineNpmClient = determineNpmClient;
function isMonorepoPackageRef(refName, root) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const c = require(`./clients/npm`);
        const newRoot = yield detectMonorepoRoot(root);
        if (newRoot) {
            const details = yield c.listPackage(refName, newRoot);
            return (_c = (_b = (_a = details === null || details === void 0 ? void 0 : details.dependencies) === null || _a === void 0 ? void 0 : _a[refName]) === null || _b === void 0 ? void 0 : _b.extraneous) !== null && _c !== void 0 ? _c : false;
        }
        return false;
    });
}
exports.isMonorepoPackageRef = isMonorepoPackageRef;
function detectMonorepoRoot(root) {
    return __awaiter(this, void 0, void 0, function* () {
        const file = yield getLernaConfigPath(root);
        if (file !== undefined) {
            return (0, path_1.dirname)(file);
        }
        let previous = root;
        do {
            const packageJson = yield (0, io_1.readJson)(root, 'package.json');
            if (Array.isArray(packageJson === null || packageJson === void 0 ? void 0 : packageJson.workspaces)) {
                return root;
            }
            previous = root;
            root = (0, path_1.dirname)(root);
        } while (root !== previous);
        return undefined;
    });
}
exports.detectMonorepoRoot = detectMonorepoRoot;
function detectMonorepo(root) {
    return __awaiter(this, void 0, void 0, function* () {
        const newRoot = yield detectMonorepoRoot(root);
        if (newRoot) {
            const file = yield getLernaConfigPath(newRoot);
            if (file !== undefined) {
                return 'lerna';
            }
            const packageJson = yield (0, io_1.readJson)(newRoot, 'package.json');
            if (Array.isArray(packageJson === null || packageJson === void 0 ? void 0 : packageJson.workspaces)) {
                return 'yarn';
            }
        }
        return 'none';
    });
}
exports.detectMonorepo = detectMonorepo;
function bootstrapMonorepo(target = '.') {
    const c = require(`./clients/lerna`);
    return c.bootstrap(target);
}
exports.bootstrapMonorepo = bootstrapMonorepo;
function installDependencies(client, target = '.') {
    const c = require(`./clients/${client}`);
    return c.installDependencies(target);
}
exports.installDependencies = installDependencies;
function installPackage(client, packageRef, target = '.', ...flags) {
    const c = require(`./clients/${client}`);
    return c.installPackage(packageRef, target, ...flags);
}
exports.installPackage = installPackage;
function publishPackage(target = '.', file = '*.tgz', flags = []) {
    const c = require(`./clients/npm`);
    return c.publishPackage(target, file, ...flags);
}
exports.publishPackage = publishPackage;
function createPackage(target = '.') {
    const c = require(`./clients/npm`);
    return c.createPackage(target);
}
exports.createPackage = createPackage;
function findTarball(packageRef) {
    const c = require(`./clients/npm`);
    return c.findTarball(packageRef);
}
exports.findTarball = findTarball;
function findSpecificVersion(packageName, version) {
    const c = require(`./clients/npm`);
    return c.findSpecificVersion(packageName, version);
}
exports.findSpecificVersion = findSpecificVersion;
function findLatestVersion(packageName) {
    return findSpecificVersion(packageName, 'latest');
}
exports.findLatestVersion = findLatestVersion;
function isLocalPackage(baseDir, fullName) {
    (0, log_1.log)('generalDebug_0003', 'Checking if its a local package ...');
    if (fullName) {
        if (/^[\.\/\~]/.test(fullName)) {
            (0, log_1.log)('generalDebug_0003', 'Found a local package by name.');
            return true;
        }
        else if (fullName.endsWith('.tgz')) {
            (0, log_1.log)('generalDebug_0003', ' Verifying if local path exists ...');
            if ((0, fs_1.existsSync)((0, path_1.resolve)(baseDir, fullName))) {
                (0, log_1.log)('generalDebug_0003', 'Found a potential local package by path.');
                return true;
            }
        }
        return fullName.startsWith(filePrefix);
    }
    return false;
}
exports.isLocalPackage = isLocalPackage;
function isGitPackage(fullName) {
    (0, log_1.log)('generalDebug_0003', 'Checking if its a Git package ...');
    if (fullName) {
        const gitted = fullName.startsWith(gitPrefix);
        if (gitted || /^(https?|ssh):\/\/.*\.git$/.test(fullName)) {
            (0, log_1.log)('generalDebug_0003', 'Found a Git package by name.');
            return true;
        }
    }
    return false;
}
exports.isGitPackage = isGitPackage;
function makeGitUrl(fullName) {
    const gitted = fullName.startsWith(gitPrefix);
    return gitted ? fullName : `${gitPrefix}${fullName}`;
}
exports.makeGitUrl = makeGitUrl;
function makeFilePath(basePath, fullName) {
    const prefixed = fullName.startsWith(filePrefix);
    const relPath = !prefixed ? fullName : fullName.replace(filePrefix, '');
    const absPath = (0, path_1.resolve)(basePath, relPath);
    return `${filePrefix}${absPath}`;
}
exports.makeFilePath = makeFilePath;
/**
 * Looks at the provided package name and normalizes it
 * resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 *   indicator if an explicit version was used,
 *   the used package type
 * ]
 * @param baseDir The base directory of the current operation.
 * @param fullName The provided package name.
 */
function dissectPackageName(baseDir, fullName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isGitPackage(fullName)) {
            const gitUrl = makeGitUrl(fullName);
            return [gitUrl, 'latest', false, 'git'];
        }
        else if (isLocalPackage(baseDir, fullName)) {
            const fullPath = (0, path_1.resolve)(baseDir, fullName);
            const exists = yield (0, io_1.checkExists)(fullPath);
            if (!exists) {
                (0, log_1.fail)('scaffoldPathDoesNotExist_0030', fullPath);
            }
            const isReference = yield isProjectReference(fullPath);
            if (isReference) {
                (0, log_1.fail)('projectReferenceNotSupported_0032', fullPath);
            }
            return [fullPath, 'latest', false, 'file'];
        }
        else {
            const index = fullName.indexOf('@', 1);
            const type = 'registry';
            if (index !== -1) {
                return [fullName.substr(0, index), fullName.substr(index + 1), true, type];
            }
            return [fullName, 'latest', false, type];
        }
    });
}
exports.dissectPackageName = dissectPackageName;
/**
 * Looks at the current package name / version and
 * normalizes it resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 * ]
 * @param baseDir The base directory of the current operation.
 * @param sourceName The used package name.
 * @param sourceVersion The used package version.
 * @param desired The desired package version.
 */
function getCurrentPackageDetails(baseDir, sourceName, sourceVersion, desired, root) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Checking package details in "${baseDir}" ...`);
        if (isLocalPackage(baseDir, desired)) {
            const fullPath = (0, path_1.resolve)(baseDir, desired);
            const exists = yield (0, io_1.checkExists)(fullPath);
            if (!exists) {
                (0, log_1.fail)('upgradePathDoesNotExist_0031', fullPath);
            }
            const isReference = yield isProjectReference(fullPath);
            if (isReference) {
                (0, log_1.fail)('projectReferenceNotSupported_0032', fullPath);
            }
            return [fullPath, getFilePackageVersion(fullPath, root)];
        }
        else if (isGitPackage(desired)) {
            const gitUrl = makeGitUrl(desired);
            return [gitUrl, getGitPackageVersion(gitUrl)];
        }
        else if (sourceVersion && sourceVersion.startsWith('file:')) {
            (0, log_1.log)('localeFileForUpgradeMissing_0050');
        }
        else if (sourceVersion && sourceVersion.startsWith('git+')) {
            if (desired === 'latest') {
                const gitUrl = desired;
                return [gitUrl, getGitPackageVersion(gitUrl)];
            }
            else {
                (0, log_1.log)('gitLatestForUpgradeMissing_0051');
            }
        }
        return [combinePackageRef(sourceName, desired, 'registry'), desired];
    });
}
exports.getCurrentPackageDetails = getCurrentPackageDetails;
function isLinkedPackage(name, type, hadVersion) {
    if (type === 'registry' && !hadVersion) {
        try {
            require.resolve(`${name}/package.json`);
            return true;
        }
        catch (_a) { }
    }
    return false;
}
exports.isLinkedPackage = isLinkedPackage;
function combinePackageRef(name, version, type) {
    if (type === 'registry') {
        return `${name}@${version || 'latest'}`;
    }
    return name;
}
exports.combinePackageRef = combinePackageRef;
function getPackageName(root, name, type) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (type) {
            case 'file':
                const originalPackageJson = yield (0, io_1.readJson)(name, 'package.json');
                if (!originalPackageJson.name) {
                    const p = (0, path_1.resolve)(process.cwd(), name);
                    const s = (0, fs_1.createReadStream)(p);
                    const i = yield (0, inspect_1.inspectPackage)(s);
                    return i.name;
                }
                return originalPackageJson.name;
            case 'git':
                const pj = yield (0, io_1.readJson)(root, 'package.json');
                const dd = pj.devDependencies || {};
                return Object.keys(dd).filter((dep) => dd[dep] === name)[0];
            case 'registry':
                return name;
        }
    });
}
exports.getPackageName = getPackageName;
function getFilePackageVersion(sourceName, root) {
    const path = (0, path_1.relative)(root, sourceName);
    return `${filePrefix}${path}`;
}
exports.getFilePackageVersion = getFilePackageVersion;
function getGitPackageVersion(sourceName) {
    return `${sourceName}`;
}
exports.getGitPackageVersion = getGitPackageVersion;
function getPackageVersion(hadVersion, sourceName, sourceVersion, type, root) {
    switch (type) {
        case 'registry':
            return hadVersion && sourceVersion;
        case 'file':
            return getFilePackageVersion(sourceName, root);
        case 'git':
            return getGitPackageVersion(sourceName);
    }
}
exports.getPackageVersion = getPackageVersion;
function getExternalsFrom(packageName) {
    try {
        return require(`${packageName}/package.json`).sharedDependencies;
    }
    catch (_a) {
        return undefined;
    }
}
function getCoreExternals(dependencies) {
    for (const frameworkLib of _1.frameworkLibs) {
        if (dependencies[frameworkLib]) {
            const deps = getExternalsFrom(frameworkLib);
            if (deps) {
                return deps;
            }
        }
    }
    return [];
}
function makePiletExternals(dependencies, externals, fromEmulator, piralInfo) {
    if (fromEmulator) {
        const { sharedDependencies = makeExternals(dependencies, externals, true) } = piralInfo;
        return sharedDependencies;
    }
    else {
        return makeExternals(dependencies, externals);
    }
}
exports.makePiletExternals = makePiletExternals;
function makeExternals(dependencies, externals, legacy = false) {
    const coreExternals = legacy ? constants_1.legacyCoreExternals : getCoreExternals(dependencies);
    if (externals && Array.isArray(externals)) {
        const [include, exclude] = externals.reduce((prev, curr) => {
            if (typeof curr === 'string') {
                if (curr.startsWith('!')) {
                    prev[1].push(curr.substr(1));
                }
                else {
                    prev[0].push(curr);
                }
            }
            return prev;
        }, [[], []]);
        const all = exclude.includes('*') ? include : [...include, ...coreExternals];
        return all.filter((m, i, arr) => !exclude.includes(m) && arr.indexOf(m) === i);
    }
    return coreExternals;
}
exports.makeExternals = makeExternals;
//# sourceMappingURL=npm.js.map